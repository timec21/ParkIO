ben şimdi bu özelliği yapmalıyım.

Sensor (Motion / Location / Environment):
o
Konum sensörü ile yakın parkları tespit etme.
o
Hareket sensörü (accelerometer) ile yürüyüş rotasında öneriler sunma.

sana projemi atıyorum tüm dosyalarımı.

index.ts
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


App.tsx
import { useEffect, useState } from 'react';
import AppNavigator from './src/navigation/AppNavigator';
import { Alert } from 'react-native';
import NetInfo from '@react-native-community/netinfo';

export default function App() {
  const [isConnected, setIsConnected] = useState<boolean | null>(true);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected);
    });
    return () => unsubscribe();
  }, []);

  const syncData = async () => {
    console.log('Veriler senkronize ediliyor...');
  };

  useEffect(() => {
    if (isConnected === false) {
      Alert.alert('Bağlantı Kesildi', 'Lütfen internet bağlantınızı kontrol edin.');
    } else if (isConnected) {
      syncData();
    }
  }, [isConnected]);
  return (
     <AppNavigator />
  );
}

app.json
{
  "expo": {
    "name": "parkIO",
    "slug": "parkIO",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.anonymous.parkIO"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "aeac82af-9f0c-459c-b785-eaea709b8cc7"
      }
    }
  }
}

src/AuthContext.tsx
import React, { useState, createContext, useEffect, useContext } from 'react';
import axios from 'axios';
import * as SecureStore from 'expo-secure-store';

interface AuthProps {
  authState?: { token: string | null; authenticated: boolean | null };
  onRegister?: (email: string, password: string) => Promise<any>;
  onLogin?: (email: string, password: string) => Promise<any>;
  onLogout?: () => Promise<any>;
  fetchUser?: () => Promise<any>; 
}

const TOKEN_KEY = 'my-jwt';
export const API_URL = 'https://api.developbetterapps.com';
const AuthContext = createContext<AuthProps>({});

export const useAuth = () => {
  return useContext(AuthContext);
};

export const AuthProvider = ({ children }: any) => {
  const [authState, setAuthState] = useState<{
    token: string | null;
    authenticated: boolean | null;
  }>({
    token: null,
    authenticated: null,
  });

  useEffect(() => {
    const loadToken = async () => {
      const token = await SecureStore.getItemAsync(TOKEN_KEY);
  
      if (token) {
        axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        setAuthState({
          token: token,
          authenticated: true,
        });
      }
    };
    loadToken();
  }, []);
  

  const fetchUser = async () => {
    try {
      const response = await axios.get(`${API_URL}/users`);
      return response.data;
    } catch (error:any) {
      console.error('Error fetching user data:', error.response?.data || error.message);
      return null;
    }
  };

  const register = async (email: string, password: string) => {
    try {
      return await axios.post(`${API_URL}/users`, { email, password });
    } catch (error) {
      return { error: true, msg: (error as any).response.data.msg };
    }
  };

  const login = async (email: string, password: string) => {
    try {
      const result = await axios.post(`${API_URL}/auth`, { email, password });

      setAuthState({
        token: result.data.token,
        authenticated: true,
      });

      axios.defaults.headers.common['Authorization'] = `Bearer ${result.data.token}`;
      await SecureStore.setItemAsync(TOKEN_KEY, result.data.token);
      return result;
    } catch (error) {
      return { error: true, msg: (error as any).response.data.msg };
    }
  };

  const logout = async () => {
    await SecureStore.deleteItemAsync(TOKEN_KEY);
    axios.defaults.headers.common['Authorization'] = '';

    setAuthState({
      token: null,
      authenticated: false,
    });
  };

  const value = {
    onRegister: register,
    onLogin: login,
    onLogout: logout,
    fetchUser, // Include here
    authState,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};


ParkContext.tsx
import React, { createContext, useState, useEffect, useContext } from 'react';

/**
 * Park arayüzü
 */
export interface Favorite {
  id: string;
  name: string;
  image: string;
  description?: string; // string | undefined olabilir
  facilities?: string[]; // string[] | undefined olabilir
  note?: string;
}

/**
 * ParkContext arayüzü
 */
interface ParkContextType {
  parks: Park[];
  favoriteParks: Park[];
  addFavorite: (park: Park) => void;
  removeFavorite: (parkId: string) => void;
  getParkDetails: (parkId: string) => Park | undefined;
}

const ParkContext = createContext<ParkContextType | undefined>(undefined);

export const ParkProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // 1) parks
  const [parks, setParks] = useState<Park[]>([]);

  // 2) favoriteParks
  const [favoriteParks, setFavoriteParks] = useState<Park[]>([]);

  // NPS API endpoint + sorgu parametresi
  // Burada kendi anahtarını ve istediğin limit'i ekle
  const API_URL = `https://developer.nps.gov/api/v1/parks?limit=50&api_key=6ON0aNJYGfGuGjhoMwGUzg80gXg95gmpzBjAXGHr`;

  useEffect(() => {
    const fetchParks = async () => {
      try {
        const response = await fetch(API_URL);
        const jsonData = await response.json();

        // NPS yanıtı şu şekilde geliyor:
        // {
        //   data: [ { park verileri... }, ... ],
        //   total: "...",
        //   limit: "...",
        //   start: "...",
        //   ...
        // }
        // O yüzden jsonData.data diyerek asıl diziye ulaşıyoruz

        if (!jsonData.data) {
          console.error('Beklenmeyen veri yapısı:', jsonData);
          return;
        }

        // Bu dizi -> jsonData.data
        // Şimdi sadece ilk 20'sini gösterelim (isteğe bağlı)
        const slicedData = jsonData.data.slice(0, 20);

        // NPS'ten gelen her park objesinde
        // `id`, `fullName`, `latLong`, `description`, `images` vb. alanlar var.
        // Bizim Park interface'ine göre "distance" alanı orijinalde yok; 
        // istersen oraya bir sabit string ya da başka bir veriyi koyabilirsin.
        const formattedParks: Park[] = slicedData.map((item: any) => ({
          // Örnek mapping: 
          // NPS'te item.id => parkın Unique ID'si, item.fullName => Adı, 
          // item.images[0].url => görsel vs.
          id: String(item.id || Math.random()), 
          name: item.fullName || 'No Name',
          distance: 'N/A', // NPS verisinde "distance" yok, buraya sabit değer koyabiliriz
          image: (item.images && item.images.length > 0) ? item.images[0].url : '',
          description: item.description ?? '',
          // facilities'leri NPS verisinde "activities" veya "topics" alanlarından toplayabilirsin.
          facilities: item.activities?.map((act: any) => act.name) ?? [],
        }));

        setParks(formattedParks);
      } catch (error) {
        console.error('Park verisi çekilirken hata:', error);
      }
    };

    fetchParks();
  }, []);

  /**
   * Favori ekleme
   */
  const addFavorite = (park: Park) => {
    setFavoriteParks((prevFavorites) => [...prevFavorites, park]);
  };

  /**
   * Favoriden çıkarma
   */
  const removeFavorite = (parkId: string) => {
    setFavoriteParks((prevFavorites) =>
      prevFavorites.filter((park) => park.id !== parkId)
    );
  };

  /**
   * Tek park detayı
   */
  const getParkDetails = (parkId: string) => {
    return parks.find((park) => park.id === parkId);
  };

  return (
    <ParkContext.Provider
      value={{
        parks,
        favoriteParks,
        addFavorite,
        removeFavorite,
        getParkDetails,
      }}
    >
      {children}
    </ParkContext.Provider>
  );
};

export const useParkContext = () => {
  const context = useContext(ParkContext);
  if (!context) {
    throw new Error('useParkContext must be used within a ParkProvider');
  }
  return context;
};

src/database/database.js
const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const bodyParser = require('body-parser');

const app = express();
const port = 3000;

// Middleware
app.use(bodyParser.json());

// SQLite Bağlantısı
const db = new sqlite3.Database('favorites.db', (err) => {
  if (err) {
    console.error('Error connecting to SQLite database:', err);
  } else {
    console.log('Connected to SQLite database.');
  }
});

// Tablo Oluştur
const createTableQuery = `
  CREATE TABLE IF NOT EXISTS favorites (
    id TEXT PRIMARY KEY,
    name TEXT,
    image TEXT,
    description TEXT,
    facilities TEXT,
    note TEXT
  )
`;
db.run(createTableQuery, (err) => {
  if (err) {
    console.error('Error creating table:', err);
  } else {
    console.log('Favorites table created or already exists.');
  }
});

// Tüm Favorileri Getir
app.get('/favorites', (req, res) => {
  db.all('SELECT * FROM favorites', [], (err, rows) => {
    if (err) {
      res.status(500).json({ error: err.message });
    } else {
      const processedRows = rows.map(row => ({
        ...row,
        facilities: row.facilities ? row.facilities.split(',') : [],
      }));
      res.json(processedRows);
    }
  });
});

// Yeni Favori Ekle
app.post('/favorites', (req, res) => {
  const { id, name, image, description, facilities } = req.body;

  if (!id || !name || !image || !description) {
    return res.status(400).json({ error: 'All fields (id, name, image, description) are required.' });
  }

  const facilitiesAsString = Array.isArray(facilities) ? facilities.join(',') : '';

  db.run(
    'INSERT INTO favorites (id, name, image, description, facilities) VALUES (?, ?, ?, ?, ?)',
    [id, name, image, description, facilitiesAsString],
    function (err) {
      if (err) {
        res.status(500).json({ error: err.message });
      } else {
        res.status(201).json({ id, name, image, description, facilities });
      }
    }
  );
});

// Favoriyi Sil
app.delete('/favorites/:id', (req, res) => {
  const { id } = req.params;

  db.run('DELETE FROM favorites WHERE id = ?', [id], function (err) {
    if (err) {
      res.status(500).json({ error: err.message });
    } else if (this.changes === 0) {
      res.status(404).json({ error: 'Favorite not found' });
    } else {
      res.status(200).json({ message: 'Favorite deleted successfully' });
    }
  });
});

// Hata Yakalama
app.use((err, req, res, next) => {
  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
    return res.status(400).json({ error: 'Invalid JSON format' });
  }
  next();
});

// Sunucuyu Başlat
app.listen(port, '0.0.0.0', () => {
  console.log(`Server is running on http://0.0.0.0:${port}`);
});

// Veritabanı Bağlantısını Kapat
process.on('SIGINT', () => {
  db.close((err) => {
    if (err) {
      console.error('Error closing SQLite database:', err);
    } else {
      console.log('SQLite database connection closed.');
    }
    process.exit(0);
  });
});

src/navigation/AppNavigation.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import SplashScreen from '../screens/SplashScreen/SplashScreen';
import HomeScreen from '../screens/HomeScreen/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen/DetailsScreen';
import FavoriteScreen from '../screens/FavoriteScreen/FavoriteScreen';
import Bottom from './Bottom';
import { ParkProvider } from '../ParkContext';
import { AuthProvider, useAuth } from '../AuthContext';

const Stack = createStackNavigator<StackParamList>();

const AuthNavigator = () => {
  const { authState } = useAuth();

  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {authState?.authenticated ? (
        <>
          <Stack.Screen name="Main" component={Bottom} />
          <Stack.Screen name="Details" component={DetailsScreen} />
          <Stack.Screen name="Favorites" component={FavoriteScreen} />
        </>
      ) : (
        <Stack.Screen name="Splash" component={SplashScreen} />
      )}
    </Stack.Navigator>
  );
};

const AppNavigator = () => (
  <AuthProvider>
    <ParkProvider>
      <NavigationContainer>
        <AuthNavigator />
      </NavigationContainer>
    </ParkProvider>
  </AuthProvider>
);

export type StackParamList = {
  Splash: undefined;
  Home: undefined;
  Details: { parkId: number };
  Favorites: undefined;
};

export default AppNavigator;


src/navigation/Bottom.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { MaterialCommunityIcons } from 'react-native-vector-icons';
import HomeScreen from '../screens/HomeScreen/HomeScreen';
import MapScreen from '../screens/MapScreen/MapScreen';
import FavoriteScreen from '../screens/FavoriteScreen/FavoriteScreen';
import NotesScreen from '../screens/NotesScreen/NotesScreen';
import ProfileScreen from '../screens/ProfileScreen/ProfileScreen';

const Tab = createBottomTabNavigator();

const BottomMenu = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;

          switch (route.name) {
            case 'Home':
              iconName = 'home';
              break;
            case 'Map':
              iconName = 'map';
              break;
            case 'Favorites':
              iconName = 'heart';
              break;
            case 'Notes':
              iconName = 'note';
              break;
            case 'Profile':
              iconName = 'account';
              break;
            case 'Details': // İkon ekleniyor
              iconName = 'information-outline';
              break;
            default:
              iconName = 'circle';
          }

          return <MaterialCommunityIcons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#EA80FC',
        tabBarInactiveTintColor: '#808080',
        tabBarStyle: {
          backgroundColor: '#1A1F1E',
          borderTopWidth: 0,
        },
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Map" component={MapScreen} />
      <Tab.Screen name="Favorites" component={FavoriteScreen} />
      <Tab.Screen name="Notes" component={NotesScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
};

export default BottomMenu;


src/navigation/HomeStack.tsx
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import HomeScreen from '../screens/HomeScreen/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen/DetailsScreen';

const Stack = createStackNavigator();

const HomeStack = () => {
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      <Stack.Screen name="HomeScreen" component={HomeScreen} />
      <Stack.Screen name="DetailsScreen" component={DetailsScreen} />
    </Stack.Navigator>
  );
};

export default HomeStack;

src/screens/DetailScreen/DetailScreen.tsx
import React, { useState } from 'react';
import { ScrollView, StyleSheet, Image, View, Alert, Modal, TextInput } from 'react-native';
import { Text, Button, Divider, Chip, IconButton } from 'react-native-paper';
import * as FileSystem from 'expo-file-system';
import { addFavoriteToAPI, Favorite } from '../../services/api';
import { useParkContext } from '../../ParkContext'; // <--- Önemli

const DetailsScreen = ({ route, navigation }: any) => {
  // route.params içinden yalnızca parkId çekiyoruz
  const { parkId } = route.params;

  // ParkContext'teki getParkDetails fonksiyonunu al
  const { getParkDetails } = useParkContext();

  // "parkId"ye göre park nesnesini bul
  const park = getParkDetails(parkId);

  // Park bulunamadıysa (id eşleşmiyorsa) bir mesaj göster
  if (!park) {
    return (
      <View style={styles.container}>
        <Text style={{ color: '#fff', textAlign: 'center' }}>
          Park verisi bulunamadı.
        </Text>
        <Button onPress={() => navigation.goBack()}>Geri Dön</Button>
      </View>
    );
  }

  // Artık park.name, park.image, park.description, park.facilities gibi alanları kullanabilirsin
  const [note, setNote] = useState('');
  const [modalVisible, setModalVisible] = useState(false);

  // Favorilere ekleme
  const handleAddFavorite = async () => {
    const favorite: Favorite = {
      id: park.id,
      name: park.name,
      image: park.image,
      description: park.description,
      facilities: park.facilities,
      note,
    };

    try {
      await addFavoriteToAPI(favorite);
      console.log('Favorilere eklendi:', favorite.name);
      setModalVisible(false);
      Alert.alert('Başarılı', 'Favorilere başarıyla eklendi.');
    } catch (error) {
      console.error('Error adding to favorites:', error);
      Alert.alert('Hata', 'Favorilere eklenirken bir sorun oluştu.');
    }
  };

  // Resmi indirme
  const handleDownloadImage = async () => {
    try {
      const fileUri = `${FileSystem.documentDirectory}${park.name.replace(/\s/g, '_')}.jpg`;
      const downloadResult = await FileSystem.downloadAsync(park.image, fileUri);
      Alert.alert('İndirme Başarılı', `Resim şu konuma kaydedildi:\n${downloadResult.uri}`);
      console.log('Downloaded to:', downloadResult.uri);
    } catch (error) {
      console.error('Error downloading image:', error);
      Alert.alert('Hata', 'Resim indirilirken bir sorun oluştu.');
    }
  };

  return (
    <>
      {/* Not Ekleme Modal */}
      <Modal visible={modalVisible} transparent animationType="slide">
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Not Ekle</Text>
            <TextInput
              style={styles.textInput}
              placeholder="Notunuzu yazın"
              value={note}
              onChangeText={setNote}
              multiline
            />
            <Button mode="contained" onPress={handleAddFavorite} style={styles.modalButton}>
              Kaydet
            </Button>
            <Button mode="text" onPress={() => setModalVisible(false)}>
              İptal
            </Button>
          </View>
        </View>
      </Modal>

      <ScrollView style={styles.container}>
        <View style={styles.header}>
          <IconButton
            icon="arrow-left"
            size={24}
            iconColor="#FFFFFF"
            onPress={() => navigation.goBack()}
            style={styles.backButton}
          />
          <Text style={styles.headerTitle}>{park.name}</Text>
        </View>

        <Image source={{ uri: park.image }} style={styles.image} />
        <Text style={styles.title}>{park.name}</Text>
        <Text style={styles.description}>{park.description}</Text>

        <Divider style={styles.divider} />

        <Text style={styles.sectionTitle}>Tesisler:</Text>
        <View style={styles.facilitiesContainer}>
          {park.facilities?.map((facility: string, index: number) => (
            <Chip key={index} style={styles.chip}>
              {facility}
            </Chip>
          ))}
        </View>

        <Divider style={styles.divider} />

        <View style={styles.actions}>
          <Button
            mode="contained"
            style={styles.button}
            onPress={() => setModalVisible(true)}
            icon="heart"
          >
            Favorilere Ekle
          </Button>
          <Button
            mode="contained"
            style={styles.button}
            onPress={handleDownloadImage}
            icon="download"
          >
            Resmi İndir
          </Button>
          <Button
            mode="outlined"
            style={styles.outlinedButton}
            icon="map-marker"
            onPress={() => console.log('Haritada Göster')}
          >
            Haritada Göster
          </Button>
        </View>
      </ScrollView>
    </>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#202124', padding: 16 },
  header: { flexDirection: 'row', alignItems: 'center', marginBottom: 16 },
  backButton: { marginRight: 8, backgroundColor: '#303134' },
  headerTitle: { fontSize: 24, fontWeight: 'bold', color: '#FFFFFF' },
  image: { width: '100%', height: 200, borderRadius: 8, marginBottom: 16 },
  title: { fontSize: 22, fontWeight: 'bold', color: '#FFFFFF', marginBottom: 8 },
  description: { fontSize: 16, color: '#D1D1D1', marginBottom: 16 },
  divider: { height: 1, backgroundColor: '#484848', marginVertical: 16 },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', color: '#FFFFFF', marginBottom: 8 },
  facilitiesContainer: { flexDirection: 'row', flexWrap: 'wrap', marginBottom: 16 },
  chip: { backgroundColor: '#303134', color: '#FFFFFF', marginRight: 8, marginBottom: 8 },
  actions: { marginTop: 16 },
  button: { backgroundColor: '#EA80FC', borderRadius: 8, marginBottom: 16 },
  outlinedButton: { borderColor: '#EA80FC', borderWidth: 1, borderRadius: 8, marginBottom: 16 },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContent: { backgroundColor: '#FFF', padding: 20, borderRadius: 10, width: '80%' },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 10, textAlign: 'center' },
  textInput: {
    borderColor: '#CCC',
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    marginBottom: 20,
    textAlignVertical: 'top',
    height: 80,
  },
  modalButton: { marginBottom: 10, backgroundColor: '#EA80FC' },
});

export default DetailsScreen;

src/screens/FavoriteScreen/FavoriteScreen.tsx
import React, { useEffect, useState } from 'react';
import { FlatList, StyleSheet, View } from 'react-native';
import { Card, Button, Text, ActivityIndicator } from 'react-native-paper';
import { fetchFavoritesFromAPI, removeFavoriteFromAPI, Favorite } from '../../services/api';

const FavoriteScreen = () => {
  const [favorites, setFavorites] = useState<Favorite[]>([]); // Favoriler listesi
  const [loading, setLoading] = useState<boolean>(true); // Yükleme durumu
  const [error, setError] = useState<string | null>(null); // Hata mesajı

  // Favorileri yükle
  useEffect(() => {
    loadFavorites();
  }, []);

  const loadFavorites = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await fetchFavoritesFromAPI();
      setFavorites(data);
    } catch (err) {
      setError('Favoriler yüklenirken bir hata oluştu.');
      console.error('Error loading favorites:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveFavorite = async (id: string) => {
    try {
      await removeFavoriteFromAPI(id);
      setFavorites((prev) => prev.filter((fav) => fav.id !== id));
    } catch (err) {
      setError('Favori silinirken bir hata oluştu.');
      console.error('Error removing favorite:', err);
    }
  };

  const renderFavorite = ({ item }: { item: Favorite }) => (
    <Card style={styles.card}>
      <Card.Cover source={{ uri: item.image }} style={styles.cardImage} />
      <Card.Content>
        <Text style={styles.cardTitle}>{item.name}</Text>
      </Card.Content>
      <Card.Actions>
        <Button
          mode="contained"
          style={styles.btn}
          onPress={() => handleRemoveFavorite(item.id)}
        >
          Favorilerden Çıkar
        </Button>
      </Card.Actions>
    </Card>
  );

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator animating={true} size="large" color="#EA80FC" />
        <Text style={styles.loadingText}>Favoriler yükleniyor...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>{error}</Text>
        <Button mode="contained" onPress={loadFavorites} style={styles.retryButton}>
          Yeniden Dene
        </Button>
      </View>
    );
  }

  return (
    <FlatList
      style={styles.bg}
      data={favorites}
      keyExtractor={(item) => item.id}
      renderItem={renderFavorite}
      contentContainerStyle={styles.list}
      ListEmptyComponent={<Text style={styles.emptyText}>Henüz bir favori eklenmedi.</Text>}
    />
  );
};

const styles = StyleSheet.create({
  bg: { backgroundColor: '#202124', paddingTop: 50 },
  list: { padding: 16 },
  card: { marginBottom: 16, backgroundColor: '#303134' },
  cardImage: { height: 150 },
  cardTitle: { fontSize: 18, fontWeight: 'bold', color: '#ffffff' },
  btn: { backgroundColor: '#EA80FC' },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#202124',
  },
  loadingText: { color: '#ffffff', fontSize: 16, marginTop: 16 },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#202124',
  },
  errorText: { color: '#EA80FC', fontSize: 16, textAlign: 'center', marginBottom: 16 },
  retryButton: { backgroundColor: '#EA80FC' },
  emptyText: {
    color: '#A1A1A1',
    fontSize: 16,
    textAlign: 'center',
    marginTop: 50,
  },
});

export default FavoriteScreen;

src/screens/HomeScreen/HomeScreen.tsx
import React from 'react';
import { View, StyleSheet, FlatList, Image } from 'react-native';
import { Card, Searchbar, Divider, Button } from 'react-native-paper';
import { useParkContext } from '../../ParkContext';

const HomeScreen = ({ navigation }: any) => {
  const { parks } = useParkContext();
  const [searchQuery, setSearchQuery] = React.useState('');

  const filteredParks = parks.filter((park) =>
    park.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const renderPark = ({ item }: any) => {
    const leftComponent = ({ size }: { size: number }) => (
      <Image
        resizeMode="cover"
        style={{ width: size, height: size, borderRadius: size / 2 }}
        source={{ uri: item.image }}
      />
    );

    return (
      <Card
        style={styles.card}
        onPress={() => navigation.navigate('Details', { parkId: item.id })}
      >
        <Card.Title
          title={item.name}
          subtitle={item.description}
          titleStyle={styles.cardTitle}
          subtitleStyle={styles.cardSubtitle}
          left={leftComponent}
        />
        <Card.Cover source={{ uri: item.image }} style={styles.cardCover} />
        <Card.Actions>
        <Button
          style={styles.btn}
          labelStyle={{ color: '#fff' }}
          onPress={() => navigation.navigate('Details', { parkId: item.id })}
        >
          İncele
        </Button>
        </Card.Actions>
      </Card>
    );
  };

  return (
    <View style={styles.container}>
      <Searchbar
        placeholder="Park Ara"
        value={searchQuery}
        onChangeText={(query) => setSearchQuery(query)}
        style={styles.searchbar}
      />
      <Divider style={styles.divider} />
      <FlatList
        data={filteredParks}
        keyExtractor={(item) => item.id}
        renderItem={renderPark}
        contentContainerStyle={styles.list}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#202124',
    padding: 16,
    paddingTop:50,
  },
  searchbar: {
    marginBottom: 16,
  },
  btn: {
    backgroundColor: '#EA80FC',
  },

  divider: {
    height: 1,
    backgroundColor: '#484848',
    marginBottom: 16,
  },
  list: {
    paddingBottom: 16,
  },
  card: {
    marginBottom: 16,
    backgroundColor: '#303134'
  },
  cardCover: {
    margin: 10,
    borderRadius: 10,
    height: 200,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  cardSubtitle: {
    fontSize: 14,
    color: '#A1A1A1',
  },
});

export default HomeScreen;


src/screens/MapScreen/MapScreen.tsx
import React, { useEffect, useState } from 'react';
import {
  StyleSheet,
  View,
  Dimensions,
  ActivityIndicator,
  Alert,
  Text,
} from 'react-native';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import axios from 'axios';

interface Park {
  id: string;
  name: string;       // Parkın ismi (ör. fullName)
  image: string;      // Tek bir resim (ör. images[0]?.url)
  latitude: number;   // Koordinat
  longitude: number;  // Koordinat
  feature1: string;   // Örnek özellik 1
  feature2: string;   // Örnek özellik 2
}

const MapScreen: React.FC = () => {
  const [parks, setParks] = useState<Park[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const fetchParks = async () => {
      try {
        const response = await axios.get('https://developer.nps.gov/api/v1/parks', {
          params: {
            limit: '30', // Kaç sonuç çekmek istediğini buradan belirle
            api_key: '6ON0aNJYGfGuGjhoMwGUzg80gXg95gmpzBjAXGHr', // Kendi API key'in
          },
        });

        // Gelen yanıt içindeki "data" dizisini al
        const rawData = response.data.data || [];

        // Gelen datayı filtrele, sadece istediğin alanları çek
        const filteredParks: Park[] = rawData
          .map((parkItem: any) => {
            // latLong: "lat:37.5858662, long:-85.67330523"
            let lat = 0;
            let long = 0;
            if (parkItem.latLong) {
              const [latStr, longStr] = parkItem.latLong
                .replace('lat:', '')
                .replace('long:', '')
                .split(', ');
              lat = parseFloat(latStr);
              long = parseFloat(longStr);
            }

            return {
              id: parkItem.id,
              name: parkItem.fullName,
              image:
                parkItem.images && parkItem.images.length > 0
                  ? parkItem.images[0].url
                  : '',
              latitude: lat,
              longitude: long,
              feature1: parkItem.description, // Örnek olarak description
              feature2: parkItem.designation, // Ya da states / topics / vb.
            };
          })
          // Koordinatı olmayanları (latitude, longitude) hariç tutmak istersen:
          .filter((park:any) => !!park.latitude && !!park.longitude);

        setParks(filteredParks);
      } catch (error) {
        console.error('Error fetching park data:', error);
        Alert.alert('Hata', 'Park verileri alınamadı.');
      } finally {
        setLoading(false);
      }
    };

    fetchParks();
  }, []);

  if (loading) {
    return (
      <View style={styles.loaderContainer}>
        <ActivityIndicator size="large" color="#EA80FC" />
      </View>
    );
  }

  if (!loading && parks.length === 0) {
    return (
      <View style={styles.loaderContainer}>
        <Text>Gösterilecek park bulunamadı.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <MapView
        provider={PROVIDER_GOOGLE} // <-- Google Maps için
        style={styles.map}
        initialRegion={{
          latitude: parks[0]?.latitude || 37.7749,
          longitude: parks[0]?.longitude || -119.4194,
          latitudeDelta: 10,
          longitudeDelta: 10,
        }}
      >
        {parks.map((park) => (
          <Marker
            key={park.id}
            coordinate={{
              latitude: park.latitude,
              longitude: park.longitude,
            }}
            title={park.name}
            // description içerisinde feature1 & feature2 gibi bilgileri gösterebilirsin
            description={`${park.feature1}\n${park.feature2}`}
          />
        ))}
      </MapView>
    </View>
  );
};

export default MapScreen;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  map: {
    width: Dimensions.get('window').width,
    height: Dimensions.get('window').height,
  },
  loaderContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});


src/screens/NotesScreen/NotesScreen.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text } from 'react-native-paper';

const NotesScreen = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Notlar Ekranı</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#202124',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: '#FFFFFF',
    fontSize: 18,
  },
});

export default NotesScreen;


src/screens/ProfileScreen/ ProfileScreen.tsx
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, Alert } from 'react-native';
import { Text, Button, Divider, Avatar } from 'react-native-paper';
import { useAuth } from '../../AuthContext';

const ProfileScreen = () => {
  const { authState, onLogout, fetchUser } = useAuth();
  const [userInfo, setUserInfo] = useState<any>(null);

  useEffect(() => {
    const loadUserData = async () => {
      try {
        const userData = await fetchUser?.();
        if (userData) {
          setUserInfo(userData);
        } else {
          console.error('Failed to fetch user data');
        }
      } catch (error) {
        console.error('Error during fetchUser call:', error);
      }
    };
    loadUserData();
  }, []);

  const handleLogout = async () => {
    await onLogout?.();
    Alert.alert('Logout', 'You have successfully logged out.');
  };

  if (!userInfo) {
    return (
      <View style={styles.loading}>
        <Text style={{ color: '#FFFFFF' }}>Loading...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
        <View style={styles.header}>
        <Avatar.Image size={100} source={{ uri: userInfo.profilePicture }} style={styles.avatar} />
        <Text style={styles.name}>{userInfo.name}</Text>
        <Text style={styles.email}>{userInfo.email}</Text>
      </View>

      <Divider style={styles.divider} />

      <View style={styles.actions}>
        <Button
          mode="contained"
          style={styles.actionButton}
          onPress={() => console.log('Edit Profile')}
        >
          Edit Profile
        </Button>
        <Button
          mode="outlined"
          style={styles.actionButtonOutlined}
          onPress={() => console.log('Update Password')}
        >
          Update Password
        </Button>
        <Button
          mode="text"
          style={styles.actionButtonText}
          onPress={handleLogout}
        >
          Logout
        </Button>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingTop: 50,
    flex: 1,
    backgroundColor: '#202124',
    padding: 16,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
  },
  avatar: {
    marginBottom: 16,
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 8,
  },
  email: {
    fontSize: 16,
    color: '#A1A1A1',
  },
  divider: {
    height: 1,
    backgroundColor: '#484848',
    marginVertical: 16,
  },
  actions: {
    marginTop: 16,
  },
  actionButton: {
    backgroundColor: '#EA80FC',
    borderRadius: 8,
    marginBottom: 16,
  },
  actionButtonOutlined: {
    borderColor: '#EA80FC',
    borderWidth: 1,
    borderRadius: 8,
    marginBottom: 16,
  },
  actionButtonText: {
    alignSelf: 'center',
  },
  loading: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#202124',
  },
});

export default ProfileScreen;

src/screens/SplashScreen/SplashScreen.tsx
import React, { useEffect, useState } from 'react';
import { Alert } from 'react-native';
import { View, StyleSheet, TextInput } from 'react-native';
import { Button } from 'react-native-paper';
import * as Animatable from 'react-native-animatable';
import { API_URL, useAuth } from '../../AuthContext';
import axios from 'axios';
const SplashScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const { onLogin, onRegister } = useAuth();

  useEffect(() => {
    const testCall = async () => {
      const result = await axios.get(`${API_URL}/users`);

      console.log("testcall Result:", result)
    }

    testCall();
  } ,[])

  const handleLogin = async () => {
    const result = await onLogin?.(email, password);
    if (result?.error) {
      Alert.alert('Error', result.msg);
    } else {
      Alert.alert('Success', 'Login successful!');
    }
  };

  const handleRegister = async () => {
    const result = await onRegister?.(email, password);
    if (result?.error) {
      console.log('Registration failed:', result.msg);
    } else {
      console.log('Registration successful');
    }
  };

  return (
    <View style={styles.background}>
      <View style={styles.overlay}>
        <Animatable.Text
          animation="bounceIn"
          duration={1500}
          style={styles.pText}
        >
          P
        </Animatable.Text>

        <Animatable.View animation="fadeInUp" duration={1200} style={styles.inputContainer}>
          <TextInput
            style={styles.input}
            placeholder="Email"
            placeholderTextColor="#A1A1A1"
            value={email}
            onChangeText={setEmail}
            keyboardType="email-address"
            autoCapitalize="none"
          />
          <TextInput
            style={styles.input}
            placeholder="Şifre"
            placeholderTextColor="#A1A1A1"
            value={password}
            onChangeText={setPassword}
            secureTextEntry
          />

          <Button
            style={[styles.btn, styles.loginBtn]}
            mode="contained"
            onPress={handleLogin}
          >
            Giriş Yap
          </Button>

          <Button
            style={[styles.btn, styles.registerBtn]}
            mode="outlined"
            onPress={handleRegister}
          >
            Kayıt Ol
          </Button>
        </Animatable.View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    backgroundColor: '#202124',
  },
  overlay: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
    paddingHorizontal: 20,
  },
  pText: {
    fontSize: 200,
    fontWeight: 'bold',
    color: '#EA80FC',
    marginBottom: 40,
    textAlign: 'center',
  },
  inputContainer: {
    width: '100%',
    alignItems: 'center',
  },
  input: {
    width: '90%',
    height: 50,
    backgroundColor: '#303134',
    borderRadius: 10,
    paddingHorizontal: 15,
    marginBottom: 20,
    fontSize: 16,
    color: '#FFFFFF',
  },
  btn: {
    width: '90%',
    height: 50,
    justifyContent: 'center',
    borderRadius: 10,
    marginTop: 10,
  },
  loginBtn: {
    backgroundColor: '#EA80FC',
  },
  registerBtn: {
    borderColor: '#EA80FC',
    borderWidth: 2,
  },
});

export default SplashScreen;

src/services/api.ts
import axios from 'axios';

export interface Favorite {
    id: string;
    name: string;
    image: string;
    description: string;
    facilities: string[];
    note?: string; // Not alanı opsiyonel olarak eklendi
  }
  

// Backend API URL'si
const API_URL = 'http://192.168.1.251:3000/favorites';

// Tüm favorileri getiren API çağrısı
export const fetchFavoritesFromAPI = async (): Promise<Favorite[]> => {
    try {
      const response = await axios.get<Favorite[]>(API_URL);
      // facilities alanını olduğu gibi döndür
      return response.data.map((favorite) => ({
        ...favorite,
        facilities: favorite.facilities, // Zaten string[] olduğu için direkt kullan
      }));
    } catch (error) {
      console.error('Error fetching favorites from API:', error);
      throw error;
    }
  };

// Yeni favori ekleyen API çağrısı
export const addFavoriteToAPI = async (favorite: Favorite): Promise<void> => {
    try {
      const payload = {
        ...favorite,
        facilities: favorite.facilities.join(','),
      };
      await axios.post(API_URL, payload);
      console.log('Favorite added to API');
    } catch (error) {
      console.error('Error adding favorite to API:', error);
      throw error;
    }
  };

// Favoriyi silen API çağrısı
export const removeFavoriteFromAPI = async (id: string): Promise<void> => {
  try {
    await axios.delete(`${API_URL}/${id}`);
    console.log('Favorite removed from API');
  } catch (error) {
    console.error('Error removing favorite from API:', error);
    throw error;
  }
};

src/utils/helper.ts
//boş
